# 템플릿 메서드
>템플릿 메서드 패턴이란?  
상위 클래스가 알고리즘 전체 구조를 정의하고, 세부 구현은 하위 클래스에서 결정하는 패턴


# 용어 정리
<details>
<summary>1. 템플릿</summary>

어떤 것을 만들기 위한 고정된 틀이나 형식.
</details>

<details>
<summary>2. 캡슐화</summary>

"캡슐화"라는 용어를 "알고리즘 전체를 하나로 묶어서 외부(사용자 코드)가 직접 순서를 바꾸지 못하게 막는다" 라는 넓은 개념으로 사용하였으며 "전략패턴의 캡슐화"와는 다를 수 있음.
</details>

<details>
<summary>3. 파이프라인</summary>

여러 단계를 정해진 순서로 흘려보내는 처리 흐름. 템플릿 메서드는 이 파이프라인의 순서를 상위에서 고정한다는 점이 핵심.
</details>

<details>
<summary>4. 알고리즘</summary>

어떤 기능을 만들기 위해 반드시 거쳐야 하는 단계들의 순서 자체를 뜻함.
</details>

<details>
<summary>5. 후크</summary>

템플릿 메서드에서 실행 여부를 서브클래스가 선택할 수 있는 선택적 확장 지점.
</details>

<details>
<summary>5. OCP</summary>

(Open-Closed-principle)
새로운 기능을 추가할 때 기존 코드를 직접 수정하지 않고 확장으로 처리해야 한다는 원칙.  
즉, 변화에는 유연하면서도 기존 안정성은 지키는 설계 철학.
</details>

<details>
<summary>6. 엔드포인트</summary>

클라이언트가 서버의 특정 기능이나 자원에 접근하기 위해 요청을 보내는 URL 주소

</details>


<br>

# 템플릿 메서드를 사용하는 이유
템플릿 메서드를 사용하는 이유는 알고리즘의 큰 틀(순서와 구조)은 변하지 않도록 보장하면서도, 세부 단계는 상황에 맞게 바꿀 수 있도록 하기 위해서다. 이렇게 하면 중복된 코드를 줄이고, 상위 클래스에서 공통된 흐름을 관리할 수 있어 유지보수가 쉬워지며, 서브클래스는 꼭 필요한 부분만 구현하면 되므로 코드 확장성도 높아진다. 또한 개발자가 실수로 전체 알고리즘의 순서를 바꿔버리는 일을 방지해 안정성을 확보할 수 있고, 변화가 생길 때도 기존 코드를 수정하지 않고 새로운 서브클래스만 추가하면 되기 때문에 OCP 원칙에도 잘 맞는 패턴이다.


<br>
<br>

# 기본 개념
템플릿 메서드는 파이프라인을 구상하고 그에 따라 고정된 순서를 상위 클래스에 캡슐화 하며 하위클래스는 이를 상속하여 그 중 필수적, 선택적인 메서드를 오버라이딩 구현하여 하위 클래스를 생성하는 패턴이다.

1. 상위 프레임워크가 최상위 흐름 메서드를 갖고있고
2. 그 메서드가 내부 로직을 단계적으로 호출을 하며
3. 각 단계가 abstract/override 가능한 보호된 메서드(후크)로 제공되며
4. 사용자는 그 후크만 구현해도 전체 알고리즘은 깨지지 않음

>## 템플릿 메서드 기본 예제
```py
class Coffee:
    def prepareRecipe(self):
        self.boilWater()
        self.brewCoffeeGrinds()
        self.pourInCup()
        self.addSugarAndMilk()

    def boilWater(self):
        print("물 끓이는 중")

    def brewCoffeeGrinds(self):
        print("필터로 커피를 내리는 중")

    def pourInCup(self):
        print("컵에 따르는 중")

    def addSugarAndMilk(self):
        print("설탕과 우유를 추가하는 중")

class Coffee:
    def prepareRecipe(self):
        self.boilWater()
        self.steepTeaBag()
        self.pourInCup()
        self.addSugarAndMilk()

    def boilWater(self):
        print("물 끓이는 중")

    def steepTeaBag(self):
        print("티백으로 홍차를 우리는 중")

    def pourInCup(self):
        print("컵에 따르는 중")

    def addSugarAndMilk(self):
        print("레몬을 추가하는 중")
```
두개의 클래스에는 공통된 알고리즘인 boilWater, pourInCup가 존재한다. 이를 묶어 상위 클래스에 고정하는 것 이 템플릿 메서드의 핵심이다. 하지만 여기서 끝나면 패턴이라는 개념으로
취급하는 일도 없었을 것이다. 조금만 더 생각해보자. 조금만 더 추상화 해보자. 홍차를 우리는 행위, 필터로 커피를 내리는 행위는 둘 다 핵심 첨가물을 우려 넣는 행위로 겹친다. 이를 추상화 하면
brew로 통일이 가능하다. 그리고 "설탕, 레몬, 우유를 추가하다"는 "Condiment(조미료)를 추가하다"로 통일이 가능하다. 이같은 행위를 추상화라고 한다.

```py
#from abc import ABC, abstractmethod 를 사용하지 않아도 템플릿 메서드를 어느정도

class CaffeineBeverage:
    def prepareRecipe(self):
        self.boilWater()
        self.I_wnat_decaffeine()
        self.brew()
        self.pourInCup()
        self.addCondiments()
        return "음료가 나왔습니다."

    def boilWater(self):
        print("물 끓이는 중")

    def brew(self):
        raise NotImplementedError

    def pourInCup(self):
        print("컵에 따르는 중")

    def addCondiments(self):
        raise NotImplementedError

    def I_wnat_decaffeine(self): #후크라는 개념을 파이썬에서는 pass로 구현 가능한 것 같음.
        pass
```
이렇게 수정이 가능하다. 여기서 self.I_want_decaffeine은 카페인을 원치않는 사람을 위해 선택 가능하도록 만들어좋은 후크이다. 이는 하위클래스에서 오버라이딩하지 않아도되고
디카페인을 원하면 오버라이딩 구현해도 된다. 이처럼 오버라이딩 할지 말지 하위클래스에 선택권을 주는것을 후크라고 한다.  
abc페키지를 사용하는 이유는 추상 메서드(abstractmethod)를 구현하지 않으면 객체 생성부터 막히게된다.
사용하지 않으면 객체생성은 되지만 객체의 메서드를 실행할 때 에러를 반환한다.

```py
class coffee(CaffeineBeverage):
    def addCondiments(self):
        print("설탕과 우유를 넣는 중..")

    def brew(self):
        print("커피를 내리는 중")

    def I_wnat_decaffeine(self):
        print("카페인을 제거한 원두를 사용한다.")
```
<br>
<br>

# 추가 예제
>## 코드는 API를 구축하는 프레임워크의 내부 로직을 아주 간단하게 축약하여 표현한 것 임.

```py
from abc import ABC, abstractmethod

class Template(ABC):
    def handle(self, request):
        self.before(request) #후크(선택)
        datas = self.fetch(request) #데이터를 그대로 출력함.(필수)
        datas = self.transform(datas) #데이터를 가공하여 출력함.(선택)
        self.after(request, datas) #후크(선택)
        return datas
    
    def before(self, request):
        pass

    @abstractmethod
    def fetch(self, request):
        raise NotImplementedError
    
    def transform(self, data): # 구현은 되어 있지만 데이터를 그대로 넘겨주므로 없는것과 마찬가지.
        return data
    
    def after(self, request, data):
        pass
```
FastAPI는 Request → (Middleware) → Routing → (Pydantic) → Endpoint → (Middleware) → Response 의 고정 흐름을 가진다. ()안에 있는 개념을 후크라고 가정하고 생각하자.  
이 중 Pydantic을 transform 후크 라 볼 수 있고 middleware는 before과 after를 담당하기에 후크라고 볼 수 있다.  


>## tranceform 후크만 구현한 상속
```py 
class RouteGet(TodoTemplate):
    def fetch(self, request):
        return [{"id" : 1, "data":"flask", "password":"1234"}, {"id" : 2,"data":"fastAPI", "password":"1234"}]
    
    def transform(self, datas):
        return [{"id": data["id"], "data": data["data"]} for data in datas] #아이디, 제목 데이터만 추출(후크 설정)

print(RouteGet().handle(request=None))
```
>결과 : [{'id': 1, 'data': 'flask'}, {'id': 2, 'data': 'fastAPI'}]

후크를 구현하지 않고 fetch만 구현하여도 data는  주어지지만 password는 숨겨야 하기에 transform 후크 메서드를 오버라이딩 하여 data가 출력되는 값을 제안하였다. 이를 FastAPI로 구현한다면 아래와 같을것이다.
우리는 befor, after(Middleware)를 오버라이딩으로 구현하지 않아도 알고리즘이 깨지지 않는것을 볼 수 있다.

>## 실제 FastAPI로 짜여지는 로직
```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

app = FastAPI()

class Item(BaseModel):
    id: int
    data: str

@app.get("/", response_model=List[Item])
def read_items():
    datas = [{"id": 1, "data": "flask", "password":"1234"},{"id": 2, "data": "fastAPI", "password":"1234"}]
    return datas
```
>터미널에서 해당 명령어 실행   
터미널1 : vicorn 파일이름:app --reload  
터미널2 : curl http://127.0.0.1:8000/ 

>결과 :
[
  {"id": 1, "data": "flask"},
  {"id": 2, "data": "fastAPI"}
]

사실 FastAPI의 내부 로직에서는 템플릿 매서드의 개념이 일부 포함되어 있지만 완벽히 대응되는 개념은 아니다. 일부 템플리 메서드의 후크 개념으로 사용되는 로직이 있지만 그것도 제한적이기 때문에 "상세 구현은 다르지만, '순서 고정'이라는 개념"에서의 정리임을 참고하길 바람.



# 응용
>## 소셜 로그인



# 내 생각
템플릿 메서드를 가장 잘 접할 수 있는것은 프레임워크라 생각한다.
프레임워크는 흐름을 고정해두고 개발자가 필요한 부분만 오버라이딩하여 사용한다는점이 템플릿 메서드와 같으며  
전체 로직(템플릿)은 바뀌지 않지만, 후크 메서드만 개발자가 구현한다는 구조가 동일하다.  
따라서 프레임워크의 동작 원리를 이해하는 데 템플릿 메서드 패턴이 핵심 개념이 될 수 있다고 생각한다.

그래서 대표적인 파이썬의 프레임워크인 FastAPI와 템플릿 메서드의 흔적을 찾아보았다.
```py 
# FastAPI 내부 로직 중 라우트 클래스(사용자가 정의한 함수를 엔드포인트로 호출)
class APIRoute(Route):
    def get_route_handler(self) -> Callable:
        async def app(request: Request) -> Response:
            # 1. 요청 검증 (고정된 절차)
            solved_values = await request_body_to_args(request)
            
            # 2. 실제 view 함수 호출 (후크: 사용자가 정의한 endpoint)
            raw_response = await dependant.call(**values)

            # 3. 응답 가공 및 반환 (고정된 절차)
            return await serialize_response(raw_response)

        return app
```
>요청 검증 → 사용자 함수 호출 → 응답 직렬화 의 알고리즘이 고정되어 있고. 사용자가 작성한 엔드포인트 함수가 후크로 들어간다.

