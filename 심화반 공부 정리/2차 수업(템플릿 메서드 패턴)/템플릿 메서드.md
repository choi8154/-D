# 템플릿 메서드
템플릿 메서드 패턴이란?  
상위 클래스가 알고리즘 전체 구조를 정의하고, 세부 구현은 하위 클래스에서 결정하는 패턴


# 용어 정리
캡슐화 : 필자는 "캡슐화"라는 용어를 "알고리즘 전체를 하나로 묶어서 외부(사용자 코드)가 직접 순서를 바꾸지 못하게 막는다" 라는 넓은 개념으로 사용하였으며 "전략패턴의 캡슐화"와는 다를 수 있음.

파이프라인 : 여러 단계를 정해진 순서로 흘려보내는 처리 흐름이다. 템플릿 메서드는 이 파이프라인의 순서를 상위에서 고정한다는 점이 핵심이다.

알고리즘 : 어떤 기능을 만들기 위해 반드시 거쳐야 하는 단계들의 순서 자체를 뜻한다

후크 : 상위가 마련한 골격 안에서 하위클래스가 끼어들 수 있는 메서드 자리다.

# 템플릿 메서드를 사용하는 이유

알고리즘 골격을 상위에서 고정해 순서·규칙을 보장하고 흔들리지 않게 만든다

공통 코드 재사용으로 중복·분기를 줄여 간결하고 안전하게 유지한다

후크(추상/기본 메서드)만 오버라이드해 세부 동작을 바꿔도 전체 흐름은 안 깨진다

OCP(개방-폐쇄 원칙)에 맞게 새 변화는 추가로, 기존 코드는 최소 수정으로 확장한다

단계가 분리돼 테스트·검증·리뷰가 쉬워지고 버그가 줄어든다

# 기본 개념
템플릿 메서드는 파이프라인을 구상하고 그에 따라 고정된 순서를 상위 클래스에 캡슐화* 하며 하위클래스는 이를 상속하여 그 중 필수적, 선택적인 메서드를 오버라이딩 구현하여 하위 클래스를 생성하는 패턴이다.

1. 상위 프레임워크가 최상위 흐름 메서드를 갖고있고
2. 그 메서드가 내부 로직을 단계적으로 호출을 하며
3. 각 단계가 abstract/override 가능한 보호된 메서드(후크)로 제공되며
4. 사용자는 그 후크만 구현해도 전체 알고리즘은 깨지지 않음

>## 코드는 API를 구축하는 프레임워크의 내부 로직을 아주 간단하게 축약하여 표현한 것 임.

```py
from abc import ABC, abstractmethod

class Template(ABC):
    def handle(self, request):
        self.before(request) #후크(선택)
        datas = self.fetch(request) #데이터를 그대로 출력함.(필수)
        datas = self.transform(datas) #데이터를 가공하여 출력함.(선택)
        self.after(request, datas) #후크(선택)
        return datas
    
    def before(self, request):
        pass

    @abstractmethod
    def fetch(self, request):
        raise NotImplementedError
    
    def transform(self, data): # 구현은 되어 있지만 데이터를 그대로 넘겨주므로 없는것과 마찬가지.
        return data
    
    def after(self, request, data):
        pass
```
FastAPI는 Request → (Middleware) → Routing → (Pydantic) → Endpoint → (Middleware) → Response 의 고정 흐름을 가진다. ()안에 있는 개념을 후크라고 가정하고 생각하자.  
이 중 Pydantic을 transform 후크 라 볼 수 있고 middleware는 before과 after를 담당하기에 후크라고 볼 수 있다.  


---
>## tranceform 후크만 구현한 상속
```py 
class RouteGet(TodoTemplate):
    def fetch(self, request):
        return [{"id" : 1, "data":"flask", "password":"1234"}, {"id" : 2,"data":"fastAPI", "password":"1234"}]
    
    def transform(self, datas):
        return [{"id": data["id"], "data": data["data"]} for data in datas] #아이디, 제목 데이터만 추출(후크 설정)

print(RouteGet().handle(request=None))
```
>결과 : [{'id': 1, 'data': 'flask'}, {'id': 2, 'data': 'fastAPI'}]

후크를 구현하지 않고 fetch만 구현하여도 data는  주어지지만 password는 숨겨야 하기에 transform 후크 메서드를 오버라이딩 하여 data가 출력되는 값을 제안하였다. 이를 FastAPI로 구현한다면 아래와 같을것이다.
우리는 befor, after(Middleware)를 오버라이딩으로 구현하지 않아도 알고리즘이 깨지지 않는것을 볼 수 있다.

----
>## 실제 FastAPI에서 짜여지는 로직
```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

app = FastAPI()

class Item(BaseModel):
    id: int
    data: str

@app.get("/", response_model=List[Item])
def read_items():
    datas = [{"id": 1, "data": "flask", "password":"1234"},{"id": 2, "data": "fastAPI", "password":"1234"}]
    return datas
```
>터미널에서 해당 명령어 실행   
터미널1 : vicorn 파일이름:app --reload  
터미널2 : curl http://127.0.0.1:8000/ 

>결과 :
[
  {"id": 1, "data": "flask"},
  {"id": 2, "data": "fastAPI"}
]

사실 FastAPI의 내부 로직에서는 템플릿 매서드의 개념이 일부 포함되어 있지만 완벽히 대응되는 개념은 아니다. 일부 템플리 메서드의 후크 개념으로 사용되는 로직이 있지만 그것도 제한적이기 때문에 "상세 구현은 다르지만, '순서 고정'이라는 개념"에서의 정리임을 참고하길 바란다.
# 추가 예제
템플릿 메서드의 정석을 보여주는 프레임워크가 여럿 있다.
웹 프레임 워크중 템플릿 메서드를 사용한 예제를 가져와 보았다.

- Java Servlet/HttpServlet.  
상위: service()가 요청 흐름을 고정(템플릿).  
하위: doGet(), doPost() 등만 오버라이드(후크).

- Flask/Werkzeug MethodView.  
상위: dispatch_request()가 골격.  
하위: get/post/put/...만 오버라이드.
```python pip install flask
from flask import Flask, jsonify
from flask.views import MethodView

app = Flask(__name__)

class TodoAPI(MethodView):
    # 후크
    def get(self):
        todos = [{"id": 1, "title": "Buy milk"}, {"id": 2, "title": "Code"}]
        return jsonify(todos)

    def post(self):
        # 새 할 일 생성 로직(생략)
        return jsonify({"ok": True}), 201

# MethodView.as_view()가 내부적으로 dispatch_request(템플릿)와 연결
app.add_url_rule("/todos", view_func=TodoAPI.as_view("todo_api"))

if __name__ == "__main__":
    app.run(debug=True)
```

# 응용
>## 소셜 로그인


# 파생 개념


# 내 생각
개발자가 템플릿 메서드를 가장 밀접하게 접할 수 있는 것은 FastAPI, Pandas, Flask 와 같은 앱 프레임워크라고 생각했다. 이유는 프레임워크에서 전체 구조를 정의하고 세부적인 요소들은 사용자에의해 정의된다는 점에서 템플리 메서드 패던과 유사하다고 생각했기 때문이다
그런점에서 나는 FastAPI 프레임워크의 로직을 확인하여 후크와 템플릿 메서드의 활용 예를 찾으려고 한것이다. 하지만 찾아보면 찾아볼수록 내 예제에는 헛점이 많았다.
먼저 FastAIP의

템플릿 메서드를 공부하면서 부트캠프 1일차에 배운 리눅스에서 piping이라는 개념이 생각이 났다. 파이밍은 한 명령의 표준출력(stdout)을 다른 명령의 표준입력에 연결하는 것인데 이것은 크게 표준입력(stdin)과 표준출력(stdout)의 과정의 프레임을 가지며 그 사이에 변화(후크)를 줄 수 있도록 설계되어 있다.  
>date | cut -- delimiter " " --fields = 1 | > today.txt  
(date를 공백으로 구분하여 필드를 만들고 첫번째 필드를 today.txt에 입력한다)

이것이 바로 파이프라인이며 데이터 가공을 |를 통해 추가시킬 수 있다. 이 개념에 도움을 받아 테플릿 메서드의 개념을 이해했다.