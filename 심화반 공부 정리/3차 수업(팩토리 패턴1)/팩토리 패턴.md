# 팩토리 패턴
>팩토리 패턴이란?  
객체의 생성 과정을 캡슐화하는 패턴.

# 용어 정리
<details>
<summary>1. 팩토리</summary>

공장에 객체 생성 책임자를 따로 둠. 객체를 직접 만들지 않고 대신 생성해주는 "객체 생성 전담 클래스"가 팩토리 패턴의 핵심.
</details>


# 팩토리 패턴을 사용하는 이유

여러 클래스를 상속하면 코드가 곳곳에 흩어져 관리가 힘듦. 때문에 한 클래스에 객체생성 코드를 클래스로 캡슐화 하여 사용자는 무엇을 만들지만 알고 어떻게 만드는지는 몰라도 됨. 즉, 생성 로직을 숨기고 코드 의존성을 줄여줌.


# 기본 개념
팩토리 패턴은 객체 생성 로직을 팩토리에 위임하여 생성과 사용을 분리하는 패턴이다.  
이를 사용하면 사용자는 구체 클래스를 모르고 팩토리 클래스의 인수만 알아도 객체 생성이 가능하다.  

>## 상위 클래스 구현
```py
from abc import ABC, abstractmethod

# 피자의 기본 구조
class Pizza(ABC):
    @abstractmethod
    def prepare(self):
        pass

    @abstractmethod
    def bake(self):
        pass

    @abstractmethod
    def cut(self):
        pass

    @abstractmethod
    def box(self):
        pass
```
상위 클래스를 추상클래스로 만들어 하위인 구체 클래스에서 메서드 구현을 하도록 만듦

>## 하위 클래스 구현
```py
class CheesePizza(Pizza):
    def prepare(self):
        print("치즈 피자 준비 중")
    def bake(self):
        print("치즈 피자 굽는 중")
    def cut(self):
        print("치즈 피자 조각 내는 중")
    def box(self):
        print("치즈 피자 포장 완료")

class PepperoniPizza(Pizza):
    def prepare(self):
        print("페퍼로니 피자 준비 중")
    def bake(self):
        print("페퍼로니 피자 굽는 중")
    def cut(self):
        print("페퍼로니 피자 조각 내는 중")
    def box(self):
        print("페퍼로니 피자 포장 완료")
```
하위 클래스에서 상위인 Pizza를 상속하여 각각의 피자를 만드는 레시피를 구현함.

>## 팩토리 클래스 구현
```py
class PizzaFactory:
    def create_pizza(self, pizza_type: str) -> Pizza:
        if pizza_type == "cheese":
            return CheesePizza()
        elif pizza_type == "pepperoni":
            return PepperoniPizza()
        else:
            raise ValueError("존재하지 않는 피자 종류입니다.")
```
팩토리 클래스를 구현하여 인수로 들어온 문자열과 일치하는 클래스 객체를 반환

>## 팩토리 사용
```py
if __name__ == "__main__":
    factory = PizzaFactory()

    # 고객이 치즈피자를 주문
    pizza = factory.create_pizza("cheese")
    pizza.prepare()
    pizza.bake()
    pizza.cut()
    pizza.box()

    print("==========")

    # 고객이 페퍼로니피자를 주문
    pizza2 = factory.create_pizza("pepperoni")
    pizza2.prepare()
    pizza2.bake()
    pizza2.cut()
    pizza2.box()
```
피자팩토리의 객체를 구현하고 반환된 클래스에 객체를 지정하여 하위 클래스의 메서드를 실행.

>## ERD
```mermaid
classDiagram
direction TB
    class Pizza {
	    +prepare() void
	    +bake() void
	    +cut() void
	    +box() void
    }

    class CheesePizza {
	    +prepare() void
	    +bake() void
	    +cut() void
	    +box() void
    }

    class PepperoniPizza {
	    +prepare() void
	    +bake() void
	    +cut() void
	    +box() void
    }

    class PizzaFactory {
	    +create_pizza(pizza_type: str) Pizza
    }

	<<abstract>> Pizza

    Pizza <|-- CheesePizza
    Pizza <|-- PepperoniPizza
    PizzaFactory ..> Pizza : creates
    PizzaFactory ..> CheesePizza : may instantiate
    PizzaFactory ..> PepperoniPizza : may instantiate


```


# 추가 예제
## sqlalchemy에서 찾아온 예제
sqlalchemy에서 아주 핵심적인 팩토리 패턴을 사용한 모듈을 예시로 들고옴.

```py
from fastapi import FastAPI
from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from pydantic import BaseModel

app = FastAPI()

DB_URL = "mysql+mypysql://root:dain8154@localhost/dbname"

engine = create_engine(DB_URL, echo=True)

Session = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

class User(Base):
    __tablename__="users"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    name = Column(String(50), nullable=False)
    age = Column(Integer, nullable=False)

class UserCreate(BaseModel):
    name: str
    age: int

Base.metadata.create_all(bind=engine)

@app.post("/Users/")
def create_user():
    pass
```
sessionmaker()는 팩토리 패턴을 사용해 Session 객체를 생성한다.
공식 문서의 요지는 “세션 생성에 필요한 옵션을 sessionmaker에 캡슐화해두면, 이후 개발자는 SessionLocal()만 호출해 일관된 세션을 손쉽게 얻는다”로 요약 가능하다.
우리는 sessionmaker 내부의 복잡한 생성 로직을 몰라도, bind, autoflush, autocommit 같은 핵심 옵션만 이해하면 입맛에 맞는 ‘세션 팩토리 인스턴스’를 만들 수 있다.
반대로 팩토리를 쓰지 않으면, 세션을 만들 때마다 옵션을 직접 적어야 해서 옵션 불일치로 인한 동작 편차와 디버깅 비용 폭증이 발생한다.
```py
session1 = Session(bind=engine, autoflush=True, expire_on_commit=True, ...)
session2 = Session(bind=engine, autoflush=True, expire_on_commit=True, ...)
```
매번 객체를 생성할 때 마다 객체생성에 필요한 속성을 설정해야하는데 이때 생기는 문제가 같은 조건의 객체를 생성 생각이었지만 실수로 다른 옵션의 객체를 생성하면
일관성 붕괴되어 우리는 객체생성 로직을 하나하나 다 확인해야하는 디버깅 지옥에 빠질것이다.

# 응용


# 내 생각
디자인 패턴의 핵심은 효율을 높이고 중복을 줄이며 가독성을 올리는 것이다. 이 목표는 대부분의 로직에서 통하지만, 다수가 각자의 프로젝트를 만드는데 쓰는 라이브러리나 프레임워크에선 특히 중요하다 생각이 든다. 공용 코드는 일관성, 확장성, 안정성을 위해 패턴 적용이 사실상 필수이 가깝다. 그래서 많은 오픈소스는 패턴을 구조에 녹여, 쓰기 쉽고 유지보수도 쉬운 형태로 제공된다고 한다. 그렇기에 패턴의 예제를 가장 빨리 이해할 수 있는 방법은 자신이 사용하고있는 라이브러리 내부에 사용된 패턴을 찾는것이 최선이 아닐까 생각해 본다.

FastAPI 교제 368p에 있는 sessionmaker 설명
> 팩토리 패턴은 소프트웨어 디자인 패턴 중 하나로, 객체의 생성 과정을 캡슐화합니다. 이 패턴은 특히 객체 생성 로직이 복잡하거나 객체를 생성할 때 다양한 옵션을 제공해야 할 때 유용합니다. sessionmaker()는 SQLAlchemy에서 팩토리 패턴의 한 예로, 데이터 베이스 세션을 생성할 때 일련의 설정을 받아 이를 반영한 세션 객체를 생성합니다.  

